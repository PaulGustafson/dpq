module AdderN where


import "lib/WithGarbage.dpq"
import "lib/Gates.dpq"

class QuantumOp a where
  unary :: (Simple a) => !(Qubit -> Qubit) -> a -> a
  copy :: (Simple a) => a -> a * a
  cnots :: (Simple a) => a -> a -> a * a

instance forall a b . (QuantumOp a, QuantumOp b, Simple a, Simple b) => QuantumOp (a * b) where
  unary g p = let (p1, p2) = p in (unary g p1, unary g p2)

  copy p =
    let (x, y) = p
        (x', x) = copy x
	(y', y) = copy y
    in ((x', y'), (x, y))
  cnots p1 p2 =
    let (x1, x2) = p1
        (y1, y2) = p2
        (x1, y1) = cnots x1 y1
	(x2, y2) = cnots x2 y2
    in  ((x1, x2), (y1, y2))



        
    

instance forall a (n :: Nat) . (QuantumOp a, Simple a) => QuantumOp (Vec a n) where
  unary g v =
    case v of
      VNil -> VNil
      VCons x xs ->
        let x' = unary g x
            xs' = unary g xs
        in VCons x' xs'

  copy l =
    case l of
      VNil -> (VNil, VNil)
      VCons x xs ->
        let (x1, x2) = copy x
	    (xs1, xs2) = copy xs
	in (VCons x1 xs1, VCons x2 xs2)    

  cnots l1 l2 =
    case l1 of
      VNil ->
       let VNil = l2 in (VNil, VNil)
      VCons x xs ->
        let VCons y ys = l2
	    (x1, y1) = cnots x y
	    (xs1, ys1) = cnots xs ys
	in (VCons x1 xs1, VCons y1 ys1)    


instance QuantumOp Qubit where
  unary g q = g q
  copy q = CNot (Init0 ()) q  
  cnots q1 q2 = CNot q1 q2


-- initQubit :: ! (Bool -> Qubit)
-- initQubit b = case b of
--                 True -> Init1 ()
-- 		False -> Init0 ()

class BooleanLogic a where
  band :: a -> a -> WithGarbage a
  bor ::  a -> a -> WithGarbage a
  bxor :: a -> a -> WithGarbage a
  bnot :: a -> WithGarbage a
  bif :: Qubit -> a -> a -> WithGarbage a


instance BooleanLogic Qubit where
  -- generate 2 garbage
  band x y =
    let z = initQubit False
        T z' y' x' = toT $ ToffoliGate True True z y x
    in dispose x' >> dispose y' >> return z'
       
  -- generate 2 garbage
  bor x y =
    let z = initQubit True
        T z' y' x' = toT $ ToffoliGate False False z y x
    in dispose x' >> dispose y' >> return z'
        

  bxor x y =
    let z = initQubit False
        (z', x') = CNot z x
	(z'', y') = CNot z' y
    in dispose x' >> dispose y' >> return z''
       

  bnot x =
    let (r, x') = CNotGate False (Init0 ()) x
    in dispose x' >> return r

  -- generate 3 garbage
  bif q q1 q2 =
       let (out1, cs) = Not_g (Init0 ()) (q1, q)
           (q1', q') = cs
           (out2, cs')  = Not_g out1 (q2, QNot q')
           (q2', q'') = cs'
     in  dispose (QNot q'') >> dispose q1' >> dispose q2' >> return out2


instance forall a b . (BooleanLogic a, BooleanLogic b) => BooleanLogic (a * b) where
  band x y =
    let (x1, x2) = x
        (y1, y2) = y in
    do r1 <- band x1 y1
       r2 <- band x2 y2
       return (r1, r2)

  bor x y =
    let (x1, x2) = x
        (y1, y2) = y in
    do r1 <- bor x1 y1
       r2 <- bor x2 y2
       return (r1, r2)


  bxor x y =
    let (x1, x2) = x
        (y1, y2) = y in
    do r1 <- bxor x1 y1
       r2 <- bxor x2 y2
       return (r1, r2)

  bnot x =
    let (x1, x2) = x in
    do r1 <- bnot x1 
       r2 <- bnot x2 
       return (r1, r2)

  bif r b c =
    let (r1, r2) = copy r
        (b1, b2) = b
        (c1, c2) = c
    in
       do rs1 <- bif r1 b1 c1
          rs2 <- bif r2 b2 c2
          return (rs1, rs2)

  


instance forall a (n :: Nat) . (BooleanLogic a) => BooleanLogic (Vec a n) where
  band x y =
    case x of
      VNil -> return y
      VCons x xs ->
        case y of
          VCons y ys ->
            do r1 <- band x y
               res <- band xs ys
               return (VCons r1 res)

  bor x y =
    case x of
      VNil -> return y
      VCons x xs ->
        case y of
          VCons y ys ->
            do r1 <- bor x y
               res <- bor xs ys
               return (VCons r1 res)

  bxor x y =
    case x of
      VNil -> return y
      VCons x xs ->
        case y of
          VCons y ys ->
            do r1 <- bxor x y
               res <- bxor xs ys
               return (VCons r1 res)

  bnot x =
    case x of
      VNil -> return VNil
      VCons x xs ->
        do x' <- bnot x
           xs' <- bnot xs
           return (VCons x' xs')

  bif r b c =
    case b of
      VNil ->
        let VNil = c in dispose r >> return VNil
      VCons x xs ->
        case c of
          VCons y ys ->
            let (r1, r2) = copy r in
            do r <- bif r1 x y
               rs <- bif r2 xs ys
               return $ VCons r rs


	

       
-- copyT :: ! (Qubit -> Triple Qubit Qubit Qubit)
-- copyT (q :: Qubit) =
--    let (q1, q3) = copy q
--        (q1, q2) = copy q1 in T q1 q2 q3


copyT :: !(Qubit -> Qubit * Qubit * Qubit)
copyT q =
   let (q1, q2) = copy q
       (q1, q3) = copy q1
   in (q1, q2, q3)


adder :: ! (Qubit -> Qubit -> Qubit -> WithGarbage (Qubit * Qubit))
adder a b carry_in =
     let (a1, a2, a3) = copyT a
         (b1, b2, b3) = copyT b
         (carry_in1, carry_in2, carry_in3) = copyT carry_in
     in do s <- [| bxor (bxor a1 b1) (pure carry_in1) |]
           carry_out <- [|bor [|bor (band a2 b2) (band a3 carry_in2)|] (band b3 carry_in3)|]
           return (s, carry_out)


nAdder :: ! (n :: Nat) -> Qubit -> Vec Qubit n -> Vec Qubit n ->
               WithGarbage (Vec Qubit n * Qubit)
-- nAdder (n :: Nat) (carry_in :: Qubit) (as bs :: Vec Qubit n) =
nAdder n carry_in as bs =
  case n of
    Z ->
     let VNil = as
         VNil = bs
     in return (VNil, carry_in)
    S n' ->
     let VCons x xs = as
         VCons y ys = bs
     in do (s, carry_out) <- adder x y carry_in
           (res, carry_out') <- nAdder n' carry_out xs ys
  	   return (VCons s res, carry_out')


nAdderRev :: ! (n :: Nat) -> Circ(Triple Qubit (Vec Qubit n) (Vec Qubit n),
                                   Vec Qubit n * Qubit *
				     Triple Qubit (Vec Qubit n) (Vec Qubit n))

nAdderRev n = box (Triple Qubit (Vec Qubit n) (Vec Qubit n)) $ \ x .
  let c = without_garbage' (Triple Qubit (Vec Qubit n) (Vec Qubit n))
            (Vec Qubit n * Qubit)
              (\ x . let T carry_in a b = x in nAdder n carry_in a b) -- f
	      (\ x . copy x) -- g
  in c x


nAdderRev_test1 :: Circ(Triple Qubit (Vec Qubit four) (Vec Qubit four),
                                   Vec Qubit four * Qubit *
				     Triple Qubit (Vec Qubit four) (Vec Qubit four))
nAdderRev_test1 = nAdderRev four

-- nAdderRev_test2 = nAdderRev nine

adding :: Triple Bool (Vec Bool four) (Vec Bool four)
adding = T False [True, False, False, True] [True, True, False, True]

-- (VCons True $ VCons False $ VCons True $ VCons False VNil)
--                    (VCons False $ VCons True $ VCons False $ VCons True VNil)

-- Due to the set up of runCirc, the call of runCirc always need annotation.
-- Moreover, we don't want to turn type class into
-- full blown prolog. 
testAdd :: Vec Bool four * Bool * Triple Bool (Vec Bool four) (Vec Bool four)
testAdd = runCirc nAdderRev_test1 adding

binaryToNat :: ! forall (n :: Nat) . Vec Bool n -> Nat
binaryToNat v =
  case v of
    VNil -> Z
    VCons x xs ->
      case x of
        True -> S (mul two (binaryToNat xs))
	False -> mul two (binaryToNat xs)

idCirc :: ! (n :: Nat) -> Circ(Vec Qubit n, Vec Qubit n)
idCirc n = box (Vec Qubit n) $ \ x . x



res :: Vec Bool four
res = fst $ fst testAdd

-- (binaryToNat res)

-- resCirc :: Circ(Vec Qubit four, Vec Qubit four)
-- resCirc = idCirc (binaryToNat res)

-- res2 :: Bool
-- res2 = runCirc (box Qubit QNot) True

-- res3 :: Vec Bool one
-- res3 = runCirc (idCirc one) [True]

-- resfour :: Bool
-- resfour = case res3 of
--             VCons x _ -> x

-- data Prop (x :: Bool) = Pr
-- data Prop1 (x :: Circ(Vec Qubit one, Vec Qubit one)) = Pr1 
-- data Prop2 (x :: Vec Bool one) = Pr2


-- tes :: ! forall a . !(a -> a)
-- tes x = x

-- t :: Prop res2
-- t = Pr 

-- idCirc1 :: Circ(Vec Qubit 1, Vec Qubit 1)
-- idCirc1 = box (Vec Qubit 1) (\ x . x)

-- t' :: Prop1 idCirc1
-- t' = Pr1

-- res5 :: Vec Bool 1
-- res5 = runCirc idCirc1 [False]

-- t2 :: Prop2 res5
-- t2 = Pr2

-- resCirc' =
--   let testAdd :: Vec Bool four * Bool * Triple Bool (Vec Bool four) (Vec Bool four)
--       testAdd = runCirc nAdderRev_test1 adding
--       circ = idCirc (binaryToNat res)

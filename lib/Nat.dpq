module Nat where
import "lib/Basics.dpq"
import "lib/Equality.dpq"



data Nat = Z | S Nat

data Maybe a = Nothing | Just a

iterN :: ! forall a . Nat -> !(a -> a) -> a -> a
iterN n f b = case n of
                  Z -> b
  		  S n' -> f (iterN n' f b)


add :: !(Nat -> Nat -> Nat)
add n m = 
  case n of
    Z -> m
    S n' -> S (add n' m) 

minus :: !(Nat -> Nat -> Nat)
minus n m = case n of
              Z -> Z
	      S n' -> case m of
	               Z -> n
	               S m' -> minus n' m'

mul :: ! (Nat -> Nat -> Nat)
mul n m = iterN n (\ x . add m x) 0

pred :: ! (Nat -> Nat)
pred n = case n of
            Z -> Z
            S m -> m
            
exponential :: ! (Nat -> Nat -> Nat)
exponential e n = iterN n (\ x . mul e x) 1


less :: ! (Nat -> Nat -> Bool)
less n m = case n of
             Z -> case m of
                   Z -> False
                   S m' -> True
             S n' -> case m of
                      Z -> False
                      S m' -> less n' m'

divMod :: !(Nat -> Nat -> Nat * Nat)
divMod x y = 
     if less x y then (0, x)
       else let u = minus x y
                (q, r) = divMod u y
            in (S q, r)

div :: !(Nat -> Nat -> Nat)
div x y = snd $ divMod x y

mod :: ! (Nat -> Nat -> Nat)
mod x y = let (_, r) = divMod x y in r

log2helper :: ! (Nat -> Nat -> Nat)
log2helper n m =
  if not $ less (exponential 2 m) n then
   m else log2helper n (S m)

log2 :: ! (Nat -> Nat)
log2 n = log2helper n Z

isOdd :: ! (Nat -> Bool)
isOdd n = let (_, rem) = divMod n 2
          in case rem of
                Z -> False
                S _ -> True

isEven :: ! (Nat -> Bool)
isEven n = not (isOdd n)


-- Some equalities about nat, for manual equality conversion.

addS1 :: ! (n m :: Nat) -> Eq Nat (add (S n) m) (S (add n m))
addS1 n m = refl

addS :: ! (n m :: Nat) -> Eq Nat (add n (S m)) (S (add n m))
addS n m = 
           case n of
             Z -> refl 
             S n' -> cong S (addS n' m)


addS' :: ! (n m :: Nat) -> Eq Nat (S (add n m)) (add n (S m))
addS' n m =  sym (add n (S m)) (addS n m)

addSS :: ! (n m :: Nat) -> Eq Nat (add n (S (S m))) (add (S (S n)) m) 
addSS n m = let p1 = addS n (S m)
                p2 = cong S (addS n m)
            in trans p1 p2

addSS' :: ! (n m :: Nat) -> Eq Nat (add (S (S n)) m) (add n (S (S m)))
addSS' n m = sym (add n (S (S m))) (addSS n m)


addOne :: ! (n :: Nat) -> Eq Nat (S n) (add n (S Z))
addOne n = case n of
              Z -> refl
              S n' -> cong S (addOne n')

addZ :: ! (n :: Nat) -> Eq Nat (add n Z) n
addZ n = case n of
           Z -> refl
           S n' -> cong S (addZ n')

addZ' :: ! (n :: Nat) -> Eq Nat n (add n Z)
addZ' n = sym (add n Z) (addZ n)

symAdd :: ! (n m :: Nat) -> Eq Nat (add n m) (add m n)
symAdd n m =
  case n of
    Z -> sym (add m Z) (addZ m)
    S n' -> trans (cong S (symAdd n' m)) (addS' m n')


minusZ :: ! (n :: Nat) -> Eq Nat n (minus n Z)
minusZ n = case n of
             Z -> refl
	     S n' -> refl

boolBot :: ! (n m :: Nat) -> Eq Bool False True -> Eq Nat n m
boolBot n m pf =
  let E pf = pf in 
    E (\ p hy . pf (\ b . 
         case b of
           False -> p n
           True -> p m ) hy)

eitherOr :: ! forall a . (x :: Bool) -> !(Eq Bool x True -> a) -> !(Eq Bool x False -> a) -> a
eitherOr x f1 f2 =
  case x of
    True -> f1 refl 
    False -> f2 refl



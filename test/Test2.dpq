module Test2 where

data Bool = True | False
object Qubit
object Bit

gate{1,1,1} H : Qubit -> Qubit
gate{1,1,1} QNot : Qubit -> Qubit
gate{1,1,1} CNot : Qubit -> Qubit -> Qubit * Qubit
gate{1,0,1} Init0 : Unit -> Qubit
gate{1,0,1} Term0 : Qubit -> Unit
gate{1,0,0} Meas : Qubit -> Bit
gate{1,0,0} Discard : Bit -> Unit

app : ! forall a b -> !(a -> b) -> !(a -> b)
app f x = f x

h'' : !(Qubit -> Qubit)
h'' = H 


h : !(Qubit -> Qubit)
h x = let y = Meas in app H x


m : !(Qubit -> Bit)
m x = app Meas x


circ1 : Circ(Qubit, Bit)
circ1 = box Qubit (\ x -> Meas (h x))


circ2 : Circ(Qubit, Unit)
circ2 = box Qubit (\ x -> Term0 (h x))

-- test1 = reverse circ1

test2 : Circ(Unit, Qubit)
test2 = reverse circ2

f2 : ! (Circ{1,0,1}(Unit, Qubit) -> Circ{1,0,0}(Unit, Qubit))
f2 x = f2 x

test2' : !(Unit -> Circ(Unit, Qubit))
test2' x = f2 test2

h' (x : Qubit) = app Meas x

-- The following show the problem due to the interaction of labeling system
-- and type classes. If we don't require annotation for type class.  
-- class Bogus a where
--   haha : a -> Bit

-- instance Bogus Qubit where
--   haha x = Meas x

-- circ3 : Circ(Qubit, Bit)
-- circ3 = box Qubit (\ x -> haha (h x))


class Bogus a where
  haha {1,0,0} : a -> Bit


instance Bogus Qubit where
  haha x = Meas x

circ3 : Circ(Qubit, Bit)
circ3 = box Qubit (\ x -> haha (h x))

-- test3 = reverse circ3

cp (x : Qubit) =
  let y = Init0 ()
  in CNot y x


boxCp = box Qubit cp

-- contrlCp = controlled boxCp
rev (x : Qubit) = (unbox (reverse boxCp)) (cp x)

-- boxRev = box Qubit rev

-- The following is an example of mode should not be shared as a global.
-- i.e., the lifting of \ x -> x should not affect the global mode.
-- g1 : ! (Qubit -> Bit)
-- g1 x = let (a, b) = (Meas x, (\ x -> x) : ! (Bool -> Bool)) in a

g1 : ! (Qubit -> Bit)
g1 x = let (a, b) = (Meas x, (\ x -> x) : ! (Bool -> Bool)) in a

g2 : ! (Qubit -> (Bool -> Bool))
g2 x = let (a, b) = (Discard (Meas x), (\ x -> x) : ! (Bool -> Bool)) in b

g3 : !(Bool -> Bool)
g3 x = g2 (Init0 ()) x

g1' : ! (Unit -> Bool -> Bool)
g1' z = let (a, b) = ((\ (x : Qubit) -> Discard (Meas x)) : !(Qubit -> Unit) , \ (x : Bool) -> x) in b

boxG1 = box Qubit g1

e : ! (Circ{1,0,0}(Qubit, Bit) -> Circ(Qubit, Bit))
e x = x

hadamard = box Qubit h

control : ! {a : Type} -> forall (b s : Type) ->
              (Simple s, Simple a, Simple b) =>
                !(a -> b) -> !(a -> s -> b * s)
control a f q s = controlled (box a f) q s

testC : !(Qubit -> Qubit -> Qubit * Qubit)
testC q s = CNot q s
-- control QNot q s

testBoxC = box (Qubit * Qubit) (\ x -> let (a, b) = x in testC a b)

testC' : !(Qubit * Qubit * Qubit -> Qubit * Qubit * Qubit)
testC' tr = let (a, b, c) = tr in controlled testBoxC (a, b) c

testBoxC' = box (Qubit * Qubit * Qubit) testC'
-- testG1 = reverse boxG1